
#Make Invalid Function which checks if Invalid already then reutrn Invalid TRUE IF NOT THEN PERFORM EXTRA CHECKS AND RETURN TRUE OR FALSE
InstructionSetOpCode={
    "mov":"000000",
    "add":"000001",
    "sub":"000010",
    "inc":"000011",
    "dec":"000100",
    "mul":"000101",
    "div":"000110",
    "and":"000111",
    "or":"001000",
    "not":"001001"
    #ror store in Deue and Use built in Rotate
    #rol
    
    }
RegistersCode={
    "ax":"000",
    "al":"000",
    "ah":"100",
    "bx":"011",
    "bl":"011",
    "bh":"111",
    "cx":"001",
    "ch":"101",
    "cl":"001",
    "dx":"010",
    "dh":"110",
    "dl":"010",
    "sp":"100",
    "bp":"101",
    "si":"110",
    "di":"111"
    
    }
RegistersValue={
    "ax":[0,0,0,0],
    "bx":[0,0,0,0],
    "cx":[0,0,0,0],
    "dx":[0,0,0,0],
    "sp":[0,0,0,0],
    "bp":[0,0,0,0],
    "si":[0,0,0,0],
    "di":[0,0,0,0]
    }
MemoryValue={
    "[0h]":"00h",
    "[1h]":"00h",
    "[2h]":"00h",
    "[3h]":"00h",
    "[4h]":"00h",
    "[5h]":"00h",
    "[6h]":"00h",
    "[7h]":"00h",
    "[8h]":"00h",
    "[9h]":"00h",
    "[ah]":"00h",
    "[bh]":"00h",
    "[ch]":"00h",
    "[dh]":"00h",
    "[eh]":"00h",
    "[fh]":"00h"
    }
MemoryCode={
    "[0h]":"0000 0000 0000 0000 0000",
    "[1h]":"0000 0000 0000 0000 0001",
    "[2h]":"0000 0000 0000 0000 0010",
    "[3h]":"0000 0000 0000 0000 0011",
    "[4h]":"0000 0000 0000 0000 0100",
    "[5h]":"0000 0000 0000 0000 0101",
    "[6h]":"0000 0000 0000 0000 0110",
    "[7h]":"0000 0000 0000 0000 0111",
    "[8h]":"0000 0000 0000 0000 1000",
    "[9h]":"0000 0000 0000 0000 1001",
    "[ah]":"0000 0000 0000 0000 1010",
    "[bh]":"0000 0000 0000 0000 1011",
    "[ch]":"0000 0000 0000 0000 1100",
    "[dh]":"0000 0000 0000 0000 1101",
    "[eh]":"0000 0000 0000 0000 1110",
    "[fh]":"0000 0000 0000 0000 1111"
    }
Example="MOV [AX+1h],[Ah]"
def OpCodeGenerator(Instruction):
    global InstructionSplit
    InstructionSplit=Instruction.lower().split(" ",1)
    global OpCode
    OpCode=InstructionSplit[0]
    
    #print(InstructionSetOpCode[OpCode])
    
def OperandGenerator(InstructionSplit):
   # print(InstructionSplit)
    OperandSplit=(InstructionSplit[1]).split(",",1)
    #print(OperandSplit)
    global Operand1
    global Operand2
    if (len(OperandSplit)==1):
        
        Operand1=OperandSplit[1]
     #   print(Operand1)
    elif (len(OperandSplit)==2):
        Operand1=OperandSplit[0]
        Operand2=OperandSplit[1]
        
        print(Operand1)
        print(Operand2)
def MemoryComponentBool():
    global Direct
    Direct=False
    global Immediate
    Immediate=False
    global RegisterDirect
    RegisterDirect=False
    global RegisterIndirect
    RegisterIndirect=False
    global RegisterRelativeOperand1
    RegisterRelativeOperand1=False
    global RegisterRelativeOperand2
    RegisterRelativeOperand2=False
    global Displacement
    if (Operand1 in RegistersCode and Operand2 in RegistersCode):
        RegisterDirect=True
        return
    if (Operand2[0]!="[" and Operand2 not in RegistersCode):
        Immediate=True
        return
    if (Operand1[0]=="[" and Operand2[0]=="["):
        global Error
        Error=True
        return
    if (Operand1[0]=='['):
        #Memory
        if (Operand1 in MemoryCode):
            Direct=True
        elif (Operand1.split("[",1)[1].split(']',1)[0] in RegistersCode):
            RegisterIndirect=True
        elif ("+" in Operand1):
            RegisterRelativeOperand1=True
    elif (Operand2[0]=='['):
        if (Operand2 in MemoryCode):
            Direct=True
        elif (Operand2.split("[",1)[1].split(']',1)[0] in RegistersCode):
            RegisterDirect=True
        elif ("+" in Operand2):
            RegisterRelativeOperand2=True
   
    
def ModGenerator():
    global MOD
    if (Immediate):
        MOD="11"
        return
    if (RegisterDirect):
        MOD="11"
    if (RegisterRelativeOperand1 or RegisterRelativeOperand2):
        MOD="01"
    elif (Operand1[0]=="[" or Operand2[0]=="["):
        MOD="00"
    else:
        MOD="-11"
def DGenerator():
    global D
    if (Immediate):
        D="0"
        return
    if (Operand2 in RegistersCode and (Operand1[0]=="[" or Operand1 in RegistersCode)):
        D="0"
    elif (Operand1 in RegistersCode and (Operand2[0]=="[" or Operand2 in RegistersCode)):
        D="1"
    
def WGenerator():
    global W
    if(Operand2 in ["al","ah","bl","bh","cl","ch","dl","dh"]):
        W="0"
    elif(Operand2 in ["ax","bx","cx","dx"]):
        W="1"
    elif(Operand2 in MemoryCode ):
        W="0"
    elif(RegisterRelativeOperand2):
        W="0"
    else:
       # Error=True
        W="-1"
def RegGenerator():
    global REG
    global R_M
    if (D=="1"):
        if (MOD=="11"):
            REG=RegistersCode[Operand1]
            if(not Immediate):
                R_M=RegistersCode[Operand2]
            else:
                R_M="000"
        elif (MOD=="01"):
             Displacement=Operand1[4:6]
             REG=RegistersCode[Operand1[1:3]]
             R_M=RegistersCode[Operand2]
        elif (MOD=="00"):
            REG=RegistersCode[Operand1[1:3]]
            R_M=RegistersCode[Operand2]
    elif(D=='0'):
        if (MOD=="11"):
            R_M=RegistersCode[Operand1]
            if(not Immediate):
                REG=RegistersCode[Operand2]
            else:
                REG="000"
        elif (MOD=="01"):
             Displacement=Operand1[4:6]
             R_M=RegistersCode[Operand1[1:3]]
             REG=RegistersCode[Operand2]
        elif (MOD=="00"):
            R_M=RegistersCode[Operand1[1:3]]
            REG=RegistersCode[Operand2]
            
def MachineCodeGenerator(Instruction):
    OpCodeGenerator(Instruction)
    OperandGenerator(InstructionSplit)
    MemoryComponentBool()
    DGenerator()
    ModGenerator()
    WGenerator()
    print(OpCode+D+W+MOD+)
        
        
OpCodeGenerator(Example)
OperandGenerator(InstructionSplit)







print("+" in Operand1)
